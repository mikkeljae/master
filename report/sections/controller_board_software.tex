%!TEX root = ../main.tex
\section{Controller Software Development} % (fold)
\label{sub:controller_board_software}

\subsection{Analysis} % (fold)
\label{sub:analysis}
\subsubsection{VHDL and Coding Practices} % (fold)
\label{ssub:vhdl_and_coding_practices}
The low level control is written in VHDL.
This is done to leverage the hard real time nature of the FPGA to create robust and dependable control of the pendulum.
As the reader likely knows, programming in VHDL can be a complex venture.
The Zynq platform adds another layer of complexity in requiring communication through the AXI Bus \ref{sec:axi}.
In order to minimize the complexity of the VHDL programming task a number of practices will be employed by the authors:
\begin{itemize}
	\item \textbf{Utilization of Test Benches:} VHDL was developed primarily as a means to simulate hardware.
	This ability means that any code can be verified in simulation before being synthesised.
	In simulation the value of any register and signal can be monitored, greatly easing the task of debugging the system.
	Additionally, each iteration is significantly faster since it foregoes the need for the complete bitstream on every iteration.
	\item \textbf{Atomic Components:} In the experience of the authors, the complexity of writing VHDL rises rapidly with the number of features of a given component.
	Writing components in their atomic form, that is, writing components with as few features as is possible, makes it significantly easier to debug and finalise each component.
	More complex components can then be made up of several smaller, known-to-function components.
	\item \textbf{Utilization of IP Cores:} Vivado, the development environment for the Zynq platform, relies heavily on the concept of Intellectual Property Cores.
	VHDL components can be compiled into an IP core which can then be easily distributed amongst multiple users.
	They also provide a means to more easily build a system by connecting several IP cores of arbitrary complexity.
\end{itemize}
In addition to the points made above, it is the expectation that a future project will develop Linux drivers which provide an intuitive interface to the firmware developed in this project.
Therefore, any tasks which may be more easily handled in C and are not necessarily as time critical as the remainder of the task will not be implemented in VHDL and is left for a future project.
% subsubsection vhdl_and_coding_practices (end)
\subsubsection{Requirement Specification} % (fold)
\label{ssub:controller_requirements}







\subsection{Design and Implementation} % (fold)
\label{sub:implementation}
\subsubsection{VHDL Components} % (fold)
\label{ssub:vhdl_components}
A number of VHDL components were designed and implemented for use on the MicroZed.
An indepth description of each is not necessary and the authors have decided to instead focus on the implementation of just the cart position counter as it provides a good description of the workflow used for each component.
\\~\\
\thomas{Part of the text below was required for me to properly write this section. Some of it may be better suited for an analysis.}
The cart position counter is, as the name implies, responsible for maintaining knowledge of the current position of the cart.
This is done by decoding the incremental quadrature of the motor and reading the state of the endstops.
Absolute knowledge of the cart position can be maintained by initially moving the cart to one of the endstops, setting the position to zero and then keeping the cart between the two endstops.
\\~\\
The component is comprised of two subcomponents.
The first is a state machine responsible for reading the current direction of travel and generating a tick on every edge of the signal.
A depiction of the state machine can be seen in figure \ref{fig:quadstatemachine}.

\begin{figure}[h]
	\centering
	\includegraphics[width=.85\linewidth]{graphics/quad_state_machine}
	\caption{State machine of the incremental quadrature decoder created for the MicroZed.}
	\label{fig:quadstatemachine}
\end{figure}

\subsubsection{Interboard Communication} % (fold)
\label{ssub:interboard_communication}
....Throughout this section this aspect is explored further.
Specifically it will be determined what data is required to be sent, and how often it is sent.
.... It is determined in \ref{ssub:wireless_transmission_of_data} that two bytes are needed to represent the joint angle....

With knowledge of the message size, it is possible to determine the theoretical maximum transmission rate.
The nRF24L01 module is capable of transmitting up to 2Mbps.
It uses Enhanced Shockburst, a protocol developed by Nordic Semiconductor specifically for their RF modules.
This protocol adds an overhead for each packet of 6 bytes, including a CRC check and an address, amongst a few other features.
Each packet is therefore $\approx$ 8 bytes with only 25\% of the packet being the intended payload.
This effectively limits the data rate to 0.5Mbps.
It is therefore possible to transmit a position at a rate of 31250Hz.
Since the two joints are communicating with the same module on the controller board, this frequency is halved resulting in 15625Hz.
Transmission at this frequency does entail a few problems, discussed in the following paragraphs.
\paragraph{nRF24L01 Mode Cycling}~\\ % (fold)
\label{par:nrf24l01_mode_cycling}
When transmitting at a rate of 15625Hz a message is to be sent every 64$\mu$s
According to the datasheet of the nRF24L01 it can be kept in transmit mode for no longer than 4ms, meaning that at the most 62 packets can be sent before cycling to standby-mode and back to TX-mode.
Before entering TX-mode a 130$\mu$s settling period is inferred.
This means that at least two packets are lost during this time.
The problem can be overcome by lowering the transmission frequency such that the time between packets is above 130$\mu$s.
6.25kHz transmission frequency would result in 160$\mu$s delay, enough time to cycle between the modes between each packet.
% paragraph nrf24l01_mode_cycling (end)
\paragraph{Air Collisions}~\\ % (fold)
\label{par:air_collisions}
There is a risk that two packets will collide if the joints transmit at the same time.
Due to uneven drift between the two microcontrollers on the joints it is unlikely that collisions will occur indefinitely, however even a few lost packets in a row can cause severe problems in the control of the pendulum.
The lowered transmission frequency alleviates this issue somewhat, but there is still a risk that multiple packets may be lost.
Air collisions could be overcome altogether by using the acknowledge feature in the Enhanced Shockburst protocol, this enables the module to resend a message if an ACK message has not been received within 250$\mu$s.
After 250$\mu$s however, the previous position is outdated and the new position should be sent rather than the lost position.
Additionally, the ACK message adds 15 bytes to the transmission of each packet, greatly lowering the possible throughput.
The nRF24L01 is capable of operating on different frequencies.
By adding a second receiver on the controller board the two joints can communicate on different frequencies, eliminating the risk of air collisions altogether.
This realisation was made after the controller board was produced and so the additional nRF24L01 has to be retrofitted on the board. 
% paragraph air_collisions (end)
\\~\\
In order to simplify communication between the joint boards and the controller board communcation will be one way only.
This allows the nRF24L01's on the controller board to stay in RX-mode, listening for new positions from the joints continuously.
The joint boards will, upon powering up, immediately start transmitting the packet mentioned in figure \ref{fig:rfpacket}.

\subsubsection{nRF24L01} % (fold)
\label{ssubs:nrf24l01}
~\\
The \texttt{nRF24L01} is interfaced through a standard SPI connection and a \texttt{CE} pin that is used to activate the chip. 
It also has a interrupt pin, but it was chosen not to use it and instead poll the device. 
Configuration of the device is done through SPI.

\paragraph{Setup} % (fold)
\label{par:setup}
~\\
Blablablalbalb.
Look at the nice flowchart and explain it.....
\missingfigure{FLOWCHART}

\paragraph{Writing to a Register} % (fold)
\label{par:writing_to_a_register}
~\\
Figure \ref{fig:rw_register} illustrates the bits that are sent to the \texttt{nRF24L01} in order to write a value to a register. 
The three command bits specify if the action to be done is read or write.
The five address bits specify address of the register that is to be written to. 
The next one to five bytes is the value that is to be written to the register.

\begin{figure}[h]
	\centering
	\includegraphics[width=.3\linewidth]{graphics/rw_register.eps}
	\caption[Writing bits to a register on nRF24L01.]{Bits written to the \texttt{nRF24L01} in order to write a value to a register. \texttt{Command} specifies if it is a read or write action, \texttt{Address} specifies the register address and \texttt{Value} specifies the value written to or read from the register.}
	\label{fig:rw_register}
\end{figure}
\mikkel{Figure should be updated with 1 byte more....}
\mikkel{FIX CODE TO NOT USE POLLED MODE - the update listing}

The C code in listing \ref{code:rf_write_register_code} is used to write a value to a register. 
Line 5 makes sure that a valid address and command is sent, regardless of the inputs.
Line 6 collects all bits that needs to be sent in one variable. 
The 2 bytes are sent using SPI in line 7, where it can also be seen that the answer from the \texttt{nRF24L01} is ignored as the \texttt{NULL} pointer is given as the input buffer.  

\begin{listing}[h]
\begin{minted}{c}
#define W_REGISTER      0b00100000
#define REGISTER_MASK   0b00011111

void RF_write_register(XSpiPs *SPI_inst, u8 reg, u8 value){
	u8 cmd_addr =  (W_REGISTER | ( REGISTER_MASK & reg));
	u8 output_buffer[] = {cmd_addr, value};
	XSpiPs_PolledTransfer(SPI_inst, output_buffer, NULL, 2);
}
\end{minted}
\caption{Implementation of a C function that writes a register value to a specific register on the \texttt{nRF24L01}. Macros are shown for clarity.}
\label{code:rf_write_register_code}
\end{listing}

The corresponding SPI signals are measured and plotted in figure \ref{fig:nrf24_spi}.
It can be seen that the \texttt{MOSI} signal corresponds to \texttt{0b00100000, 0b00110101}, which means that the value \texttt{0b00110101} is written to the \texttt{RF\_CONFIG} register which has address \texttt{0x00}.
It can also be noted the data is available on the \texttt{MISO} signal. 
The \texttt{nRF24L01} always responds with the value of the \texttt{STATUS} when detecting a falling edge on \texttt{SS}.

\begin{figure}[h]
	\centering
    \input{graphics/nrf24_spi.tex}
	\caption[SPI communication between nRF24 and the MicroZed]{SPI communication between \texttt{nRF24} and the MicroZed. Shown is a write command of \texttt{RF\_CONFIG} register, \texttt{0x00}. The value written to the \texttt{RF\_CONFIG} register is \texttt{0b00110101}. 2 bytes are exchanged in total. The SPI transmission is setup and measured at 625kHz, for readability.}
	\label{fig:nrf24_spi}
\end{figure}

\paragraph{Reading a Payload} % (fold)
\label{par:reading_a_payload}
~\\
Reading a payload from the \texttt{nRF24L01} is done as shown in figure \ref{fig:rxtx_payload}.
In general the first byte corresponds to the command given. 
In this case it would be \texttt{0b01100001} in order to read a payload.
The payload is the next one to 32 bytes sent by the \texttt{nRF24L01}.
\begin{figure}[h]
	\centering
	\includegraphics[width=.6\linewidth]{graphics/rxtx_payload.eps}
	\caption[Reading a payload on the nRF24L01.]{Bits written to and received from the \texttt{nRF24L01} when reading a payload. \texttt{Command} specifies the command given and \texttt{Payload} is the bits written from the \texttt{nRF24L01}.}
	\label{fig:rxtx_payload}
\end{figure}

Listing \ref{code:rf_read_payload} shows how a payload of 32 bytes are read in C code. 
Line 5 defines the input and output buffers and line 6 assigns the read payload command to the first byte of the output buffer.
33 bytes of data is sent in line 7, this is needed in order to create the clock signal for the \texttt{nRF24L01}, when it sends the 32 bytes payload.
The payload is also read and assigned to the input buffer in line 7.
Line 8-11 extracts the 32 bytes payload and ignores the first byte sent from the \texttt{nRF24L01}, which is the value of the \texttt{STATUS} register.

\begin{listing}[h]
\begin{minted}{c}
#define R_RX_PAYLOAD       0b01100001
#define PAYLOAD_SIZE       32

void RF_read(XSpiPs *SPI_inst, u8 *buffer){
	u8 input_buffer[PAYLOAD_SIZE+1], output_buffer[PAYLOAD_SIZE+1];
	output_buffer[0] = R_RX_PAYLOAD;
	XSpiPs_PolledTransfer(SPI_inst, output_buffer, input_buffer, PAYLOAD_SIZE+1);
	int i;
	for(i = 1; i < PAYLOAD_SIZE+1; i++){
		buffer[i-1] = input_buffer[i];
	}
}
\end{minted}
\caption{Implementation of a C function that reads 32 bytes payload from the \texttt{nRF24L01}. Macros are shown for clarity.}
\label{code:rf_read_payload}
\end{listing}

\subsubsection{PWM Generation} % (fold)
\label{ssub:pwm_generation}
In order to generate the two needed PWM signals from the Microzed an IP core must be made in VHDL.
As described the IP core needs to be able to switch the PWM signal between channel \texttt{A} and \texttt{B} and have a programmable duty cycle.
It also needs to have a top signal that indicates the center of the PWM pulse.
The designed PWM generator IP core has three inputs and three outputs as illustrated in figure \ref{fig:pwm_gen_component}.

\mikkel{Make sure this is actually described in the analysis and requirements.}
\begin{figure}[h]
	\centering
	\includegraphics[width=.4\linewidth]{graphics/pwm_gen_component.png}
	\caption{Input and output signals of the PWM generator component.}
	\label{fig:pwm_gen_component}
\end{figure}
A counter is incremented to a high limit and decremented to zero using a state machine.
The high limit for the counter when using the Microzed and a PWM frequency of 22KHz is calculated by:
\begin{equation}
	H_{limit} = \frac{F_{Microzed}}{F_{PWM}\cdot 2} = \frac{100\cdot 10^6}{22\cdot 10^6 \cdot 2} = 2272.7 \simeq 2273
\end{equation}
Where $H_{limit}$ is the high counting limit, $F_{Microzed}$ and $F_{PWM}$ are the frequencies of the Microzed and the PWM, respectively. 
The PWM output will be set \texttt{high}, when the counter value is greater than a compare value.
Using this mechanism the duty cycle of the PWM can be controlled through the compare value.
The compare value for a 50\% dutycycle should be calculated using:
\begin{equation}
	Compare = (1 - D) \cdot H_{limit} = (1 - 0.5) \cdot 2273 = 1136
\end{equation}
Where $Compare$ is the compare value and $D$ is the wanted dutycycle ratio.

The described mechanism is illustrated in figure \ref{sfig:pwm_gen_int}, where the top signal is simply set \texttt{high}, when counter reaches is high limit.

\begin{figure}
    \centering
    \begin{subfigure}[b]{0.45\textwidth}
        \input{graphics/vhdl_pwm_gen_int.tex}
        \caption{Internal VHDL signals illustrated by a Matlab plot.}
        \label{sfig:pwm_gen_int}
    \end{subfigure}
    \begin{subfigure}[b]{0.45\textwidth}
        \input{graphics/vhdl_pwm_gen.tex}
        \caption{External PWM signal measured using an oscilloscope. }
        \label{sfig:pwm_gen_ext}
    \end{subfigure}
    \caption[Signals associated with the PWM generator IP core]{Internal and external signals associated with the PWM generator IP core. PWM and TOP are logic signals and 2000 represents their \texttt{high} value.}
    \label{fig:vhdl_pwm_gen}
\end{figure}

Generating the PWM signal from the counter and compare values is done in lines 5 to 11 of listing \ref{code:vhdl_pwm_gen}.
Setting the PWM on to the correct channel is done in lines 12 to 16.
As \texttt{pwm\_a\_l} and \texttt{pwm\_b\_l} are written to in a process, they will only be updated with the last written value, when the process is left.

\begin{listing}[h]
\begin{minted}{vhdl}
OUTPUT_DECODE: process (state,counter,dir)
begin
	@$\vdots$@
if (counter > unsigned(comp_value)) then
		pwm_a_l <= '1';
		pwm_b_l <= '1';
	else
		pwm_a_l <= '0';
		pwm_b_l <= '0';
	end if;	
	if( dir = '1') then 
		pwm_b_l <= '0';
	else 
		pwm_a_l <= '0';	
	end if;
end process;		
\end{minted}
\caption{VHDL code }
\label{code:vhdl_pwm_gen}
\end{listing}

	

\subsection{Verification} % (fold)
\label{sub:verification}
