%!TEX root = ../main.tex
\section{Controller Software Development} % (fold)
\label{sub:controller_board_software}

\subsection{Analysis} % (fold)
\label{sub:analysis}
This section will seek to analyse the requirements for the software that runs on the Microzed mounted on the controllerboard.
The software will need to serve as a base system, where control algorithms can be run for verification purposes.
It is not intended as the final system as that system should be Linux based and imposes a completely different set of requirements on the system.

\subsubsection{Cart Position}
\label{ssub:cart_position}
In order to control the position of the cart it is important to know its absolute position.
The \texttt{HEDS5540} \cite{heds5540} encoder mounted on the motor has an \texttt{A}, \texttt{B} and \texttt{Z} incremental quadrature and can be used to measure the relative position of the cart. 
The absolute position of the cart should be referred to the rail and therefore the \texttt{Z} signal cannot be used to determine the absolute position.
The endstops have fixed positions on the rail and the signals from them can therefore be used to infer the absolute position.
Specifically, resetting the position when reaching endstop 1 should be done to calibrate the system.
Hereafter the absolute position can be measured by reading signals \texttt{A} and \texttt{B}.

Implementing this functionality on an FPGA using VHDL has the advantage that all signals can be read simultaneously.
This means that a correct VHDL design will ensure that no edges on pins can go unnoticed.
Furthermore it has the advantage that the processor does not need to do any computation and no jitter is introduced, since no interrupts are used. 
Therefore it was decided to implement the functionality of measuring absolute cart position in a VHDL module.


\subsubsection{Controlling the Motor Driver} % (fold)
\label{ssub:controlling_the_motor_driver}
The motor driver has three inputs that need to be produced by the controller board software.
More Specifically, two PWM inputs and a disable pin that disables the outputs of the motor driver.
The PWM signals will be applied to the motor and therefore it was chosen to use a frequency of 22kHz in order to be outside of the audible range.
It was decided to only apply a PWM signal to one channel in order to reduce the stress and current through the MOSFET and the motor.
This means that in order to change direction of the motor, the PWM signal needs to be switched between the two PWM channels.
The duty cycle of the PWM needs to be adjustable in order to control the speed of the motor.
It is beneficial to implement the PWM generation on the FPGA part of the Microzed as it has no dedicated PWM generating hardware and implementing it in software would require computational time on the processor.

\subsubsection{General Peripheral Hardware Control} % (fold)
\label{ssub:general_peripheral_hardware}
As described in section \ref{ssub:relay_circuitry}, two relays should be controlled by the controller board software. 
An inrush relay that allows for safe charging of the capacitor bank and the main relay. 
Both are controlled by controlling the logic level of an output pin.
Furthermore the software needs to control the three RGB LEDs on the controller board. 
In order to utilize the full functionality of the RGB LEDs each channel of the LED should be controlled by a PWM signal.
Using this method the LED can be illuminated in all colours.
The frequency of the PWM is not of great concern as long as it is faster than human eye. 
A higher frequency means a higher loss in the MOSFETs and therefore a frequency of 1kHz was chosen, this is fast enough to avoid visible flickering.

\subsubsection{Interboard Communication} % (fold)
\label{ssub:interboard_communication}
The joint boards need to transmit joint angles to the controllerboard wirelessly using the \texttt{nRF24L01} module.
In section  \ref{ssub:wireless_transmission_of_data} is determined that two bytes are needed to represent the joint angle data.
The rate of transmission of joint angles should be as high as possible while still maintaining reliable transmission.
Throughout this section this aspect is explored further.

With knowledge of the message size, it is possible to determine the theoretical maximum transmission rate.
The \texttt{nRF24L01} module is capable of transmitting up to 2Mbps.
It uses Enhanced Shockburst, a protocol developed by Nordic Semiconductor specifically for their RF modules.
This protocol adds an overhead for each packet of 6 bytes, including a CRC check and an address, amongst a few other features.
Each packet is therefore $\approx$ 8 bytes with only 25\% of the packet being the intended payload.
This effectively limits the data rate to 0.5Mbps.
It is therefore possible to transmit a position at a rate of 31250Hz.
Since the two joints are communicating with the same module on the controller board, this frequency is halved resulting in 15625Hz.
Transmission at this frequency does entail a few problems, discussed in the following paragraphs.
\paragraph{nRF24L01 Mode Cycling}~\\ % (fold)
\label{par:nrf24l01_mode_cycling}
When transmitting at a rate of 15625Hz a message is to be sent every 64$\mu$s
According to the datasheet of the nRF24L01 it can be kept in transmit mode for no longer than 4ms, meaning that at the most 62 packets can be sent before cycling to standby-mode and back to TX-mode.
Before entering TX-mode a 130$\mu$s settling period is inferred.
This means that at least two packets are lost during this time.
The problem can be overcome by lowering the transmission frequency such that the time between packets is above 130$\mu$s.
%6.25kHz transmission frequency would result in 160$\mu$s delay, enough time to cycle between the modes between each packet.


\paragraph{Air Collisions}~\\
\label{par:air_collisions}
There is a risk that two packets will collide if the joints transmit at the same time.
Due to uneven drift between the two microcontrollers on the joints it is unlikely that collisions will occur indefinitely, however even a few lost packets in a row can cause severe problems in the control of the pendulum.
The lowered transmission frequency alleviates this issue somewhat, but there is still a risk that multiple packets may be lost.
Air collisions could be handled by using the acknowledge feature in the Enhanced Shockburst protocol, this enables the module to resend a message if an ACK message has not been received within 250$\mu$s.
After 250$\mu$s however, the previous position is outdated and the new position should be sent rather than the lost position.
Additionally, the ACK message adds 15 bytes to the transmission of each packet, greatly lowering the possible throughput.
The nRF24L01 is capable of operating on different frequency-bands.
By adding a second receiver on the controller board the two joints can communicate on different frequencies, eliminating the risk of air collisions altogether.
This realisation was made after the controller board was produced and so the additional \texttt{nRF24L01} has to be retrofitted on the board. 
% paragraph air_collisions (end)
\\~\\
In order to simplify communication between the joint boards and the controller board communcation will be one way only.
This allows the nRF24L01's on the controller board to stay in RX-mode, listening for new positions from the joints continuously.
The joint boards will, upon powering up, immediately start transmitting the packet mentioned in figure \ref{fig:rfpacket}.

\subsubsection{Utilizing the Zynq Platform} % (fold)
\label{ssub:utializing_the_zynq_platform}
The Microzed has a Xilinx Zynq 7020 chip embedded on the board. 
This chip has both a Processing System, PS, and Programmable Logic, PL, which enables the use of both concurrent and sequential computing on the same board. 
The PS is a dual core ARM Cortex-A9 processsor and PL is an Artix-7 FPGA \cite{zynq_data_sheet}.
The two parts are connected through the AXI bus.

\paragraph{Concurrent Computing} % (fold)
\label{par:concurrent_computing}
Programming a FPGA will be done using VHDL,
In order to   
\mikkel{Some more.}
Concurrent computing has the advantage that it is executed in true parallel.
Inherently real time....

\paragraph{Sequential Computing} % (fold)
\label{par:sequential_computing}

\paragraph{The AXI Bus and IP Cores} % (fold)
\label{par:the_axi_bus}
The AXI, Advance eXtensible Interface, standard is part of Arm AMBA, an industry standard for communication between components on SoC's.
AXI4 has been co-developed with Xilinx in an effort to tailor it for use in FPGA's.
Perhaps not surprisingly, Xilinx uses this protocol extensively in their IP, Intellectual Property.
It increases portability by allowing a single interface between different components.
The use of IP allows companies to share functionality without disclosing the underlying code, but also simplifies the connection of various components since every component can be verified independently of the others and can be easily connected using the Block Design feature of Vivado.
AXI is a memory-mapped interface, meaning that communication through the bus is essentially a controlled sharing of specific memory.
Communication between PS and PL requires the use of the AXI bus.
\\~\\
There are three different implementations of the AXI bus:
\begin{itemize}
	\item \textbf{AXI4-Full:} This implementation enables burst transmissions, allowing multiple data transmissions per interaction.
	\item \textbf{AXI4-Lite:} This implementation is lower bandwidth than the above implementation but is especially useful for setting control registers and transmitting low volumes of data.
	\item \textbf{AXI4-Stream:} This implementation foregoes the use of addresses and allows a continuous stream of data.
\end{itemize}
Since the data exchanged between PL and PS in this project is mostly the setting of control registers and reading cart positions at a steady rate the simpler AXI4-Lite implementation is going to be used for the components created in this project.
\subsubsection{Real Time} % (fold)
\label{ssub:real_time}
\thomas{nice section on some of the reasons why real time is required}
bla.bla.bla.

\subsubsection{VHDL and Coding Practices} % (fold)
\label{ssub:vhdl_and_coding_practices}
The low level control is written in VHDL.
This is done to leverage the hard real time nature of the FPGA to create robust and dependable control of the pendulum.
As the reader likely knows, programming in VHDL can be a complex venture.
The Zynq platform adds another layer of complexity in requiring communication through the AXI Bus.
In order to minimize the complexity of the VHDL programming task a number of practices will be employed by the authors:
\begin{itemize}
	\item \textbf{Utilization of Test Benches:} VHDL was developed primarily as a means to simulate hardware.
	This ability means that any code can be verified in simulation before being synthesised.
	In simulation the value of any register and signal can be monitored, greatly easing the task of debugging the system.
	Additionally, each iteration is significantly faster since it foregoes the need for the complete bitstream on every iteration.
	\item \textbf{Atomic Components:} In the experience of the authors, the complexity of writing VHDL rises rapidly with the number of features of a given component.
	Writing components in their atomic form, that is, writing components with as few features as is possible, makes it significantly easier to debug and finalise each component.
	More complex components can then be made up of several smaller, known-to-function components.
	\item \textbf{Utilization of IP Cores:} Vivado, the development environment for the Zynq platform, relies heavily on the concept of Intellectual Property Cores.
	VHDL components can be compiled into an IP core which can then be easily distributed amongst multiple users.
	They also provide a means to more easily build a system by connecting several IP cores of arbitrary complexity.
\end{itemize}
In addition to the points made above, it is the expectation that future developers will develop Linux drivers which provide an intuitive interface to the firmware developed in this project.
Therefore, any tasks which may be more easily handled in C and are not necessarily as time critical as the remainder of the task will not be implemented in VHDL and is left for a future project.


\subsubsection{Requirement Specification} % (fold)
\label{ssub:controller_requirements}

\paragraph{Functional:}
\begin{enumerate}[resume]
	\item Correct cart position should be known at all times.
	\begin{itemize}
		\item Encoder signals should be used to measure relative position.
		\item Endstop signal should be used to calibrate and infer the absolute position.
	\end{itemize}
	\item General peripheral hardware should be controlled
	\begin{itemize}
		\item Main relay and inrush relay should be controlled through output pins.
		\item 3 channel 1kHz PWM with adjustable dutycycle should control each RGB LED.
	\end{itemize}
	\item Software should produce correct signals to motor driver that allows for control of speed and direction of the motor.
	\begin{itemize}
		\item 22kHz PWM signals on two channels.
		\item Adjustable dutycycle.
		\item Control \texttt{DIS} signal.
 	\end{itemize}
	\item Receive joint angle data from the two joint boards using the \texttt{nRF24L01} module
	\begin{itemize}
		\item Setup of Microzed as SPI master.
		\item Setup of \texttt{nRF24L01} settings.
		\item Receive joint angle data form joint boards.
	\end{itemize}
	\item Real time behaviour of software.
\end{enumerate}

\paragraph{Design:}
\begin{enumerate}[resume]
	\item VHDL should be designed and implemented using the following practices.
	\begin{itemize}
		\item Utilization of Test Benches.
		\item Atomic Components.
		\item Utilization of IP Cores.
	\end{itemize}
\end{enumerate}
\paragraph{Safety:}
\begin{enumerate}[resume]
	\item Software should handle emergency situations.
	\begin{itemize}
		\item Should detect emergency condition.
		\item Should be able to produce an emergency signal.
	\end{itemize}
\end{enumerate}

\subsection{Design and Implementation} % (fold)
\label{sub:implementation}
\subsubsection{Implementation of Cart Position Counter} % (fold)
\label{ssub:vhdl_components}
A number of VHDL components were designed and implemented for use on the MicroZed.
An indepth description of each is not necessary and the authors have decided to instead focus on the implementation of just the cart position counter as it provides a good description of the workflow used for each component.

\thomas{Part of the text below was required for me to properly write this section. Some of it may be better suited for an analysis.}
The cart position counter is, as the name implies, responsible for maintaining knowledge of the current position of the cart.
This is done by decoding the incremental quadrature of the motor and reading the state of the endstops.
Absolute knowledge of the cart position can be maintained by initially moving the cart to one of the endstops, setting the position to zero and then keeping the cart between the two endstops.
The decoding task is done by a seperate component which is then instansiated in the counting component.

\paragraph{Incremental Quadrature Decoding}~\\ % (fold)
\label{par:incremental_quadrature}
The motor provides three signals for incremental quadrature, \texttt{A}, \texttt{B} and \texttt{Z}. 
Figure \ref{fig:quadrature} is a depiction of this quadrature scheme.
The two signals \texttt{A} and \texttt{B} are 90$^\circ$ out of phase and their frequency is determined by the angular velocity of the joint.
As can be seen from the figure the signals create four unique stages, counting these allows knowledge of both the direction, position and, potentially, the velocity of the joint.
The \texttt{Z} signal is a unique pulse which happens on every revolution of the motor.
This signal is not used in this VHDL component as the angular position of the motor is irrelevant in relation to the position of the cart.

\begin{figure}[h]
	\centering
	\includegraphics[width=.5\linewidth]{graphics/quadrature}
	\caption{Incremental quadrature scheme as implemented on the \texttt{HEDS5540}.}
	\label{fig:quadrature}
\end{figure}

\paragraph{State Machine Structure}~\\ % (fold)
\label{par:state_machine_structure}
Each state machine written for this project is done using a Moore SM in a three-part structure:
\begin{itemize}
	\item \textbf{Sync Process:} This is the only process which is synchronized with the clock signal.
	It is used to ensure that state and signals are changed only on the rising edge of the clock.
	\item \textbf{Output Decode:} In each state the output signals are to be in a specific configuration.
	Given any state, this process ensures that the signals are in that configuration.
	\item \textbf{Next State Decode:} In this process the next state is determined based on the current state and the current inputs.
\end{itemize}
Using this structure ensures that each process has one responsibility and will generally result in cleaner, more simple code.
\\~\\
The component described in this section is comprised of two subcomponents.
The first is a state machine responsible for reading the current direction of travel and generating a tick on every edge of signals \texttt{A} and \texttt{B}.
A depiction of the SM responsible for decoding the incremental quadrature can be seen in figure \ref{fig:quadstatemachine}.
On this figure \texttt{A}, \texttt{B} and \texttt{Z} are the quadrature signals, \texttt{p} and \texttt{pl} are the \texttt{phase} and \texttt{last\_phase} variables, \texttt{T\_i}, \texttt{D\_i} and \texttt{I\_i} are the \texttt{tick}, \texttt{direction} and \texttt{index} variables.
Note that VHDL notation has been omitted for clarity.
As can be seen, the SM is comprised of six states, explained in more detail in the following paragraphs.
\begin{figure}[h]
	\centering
	\includegraphics[width=.85\linewidth]{graphics/quad_state_machine}
	\caption{State machine of the incremental quadrature decoder created for the MicroZed.}
	\label{fig:quadstatemachine}
\end{figure}
\paragraph{st1\_idle:} % (fold)
Is the initial state and the state that is returned to between edges on the quadrature signal.
Since the quadrature signal is not synchronous with the driving clock of the system the \texttt{rising\_edge()} and \texttt{falling\_edge()} functions cannot be used to determine edges.
Listing \ref{code:edge_detection} shows how an edge is detected on a signal. 
The current value of the signal is continuously compared to the last value, which is saved on every clock cycle.
If the two values are not equal an edge must have occured within the last clock cycle.
In this component both rising and falling edges are used and so any difference between the two is registered.
This code is repeated for all three input signals, with the exception that the \texttt{Z} channel sets \texttt{next\_state} to \texttt{st6\_index} instead.

\thomas{appropriate captions on listings}
\begin{listing}[h]
\begin{minted}{vhdl}
case (state) is
	when st1_idle =>
		if A_i /= last_A_i then
	        next_state <= st2_edge;
	    end if;
	    @$\vdots$@
\end{minted}
\caption{VHDL code}
\label{code:edge_detection}
\end{listing}

\paragraph{st2\_edge:} % (fold)
Is responsible for determining which phase is currently active.
The different phases can be seen in figure \ref{fig:quadrature}.
The phase is found simply by comparing the signals as seen in listing \ref{code:phase_detection}.
Regardless of the detected phase \texttt{next\_state} is set to \texttt{st3\_dir}.
\begin{listing}[h]
\begin{minted}{vhdl}
when st2_edge =>
	if A = '1' then
	    if B = '1' then
	        phase <= p4;
	    else
	        phase <= p3;
	    end if;
	    next_state <= st3_dir;
	    @$\vdots$@
\end{minted}
\caption{VHDL code}
\label{code:phase_detection}
\end{listing}
\paragraph{st3\_dir:} % (fold)
Determines the current direction of travel.
This can be seen by comparing the current phase to the last phase.
Listing \ref{code:determine_direction} shows the structure of the code responsible for this step.
\begin{listing}[h]
\begin{minted}{vhdl}
when st3_dir =>
	if last_phase /= p0 then
	    if phase = p1 then
	        if last_phase = p4 then
	            next_state <= st5_ccw;
	        end if;
	        if last_phase = p2 then
	            next_state <= st4_cw;
	        end if;
	        next_last_phase <= p1;
	    end if;
	    if phase = p2 then
	    @$\vdots$@
    else
        next_last_phase <= phase;
        next_state <= st1_idle;
    end if;
\end{minted}
\caption{VHDL code}
\label{code:determine_direction}
\end{listing}
As can be seen in the code there is a reference to phase 0.
This is required since the initial phase is unknown.
During the first run the direction-determination is skipped and \texttt{last\_phase} is initialized to phase.
On every subsequent run, depending on the direction, \texttt{next\_state} is set to either \texttt{st4\_cw} or \texttt{st5\_ccw}.
\paragraph{st4\_cw and st5\_ccw:} % (fold)
The SM is in these states for one clock cycle to allow for the outputs to be adjusted and a tick to be generated.
\paragraph{st6\_index:} % (fold)
The SM is in this state for one clock cycle when the \texttt{Z} input goes high and generates a signal to indicate that the index has been reached.
While this feature is unused in the cart position counter as it currently exists, it was decided to include it to allow future developers to use it if the need arises.

\paragraph{Cart Position Counter}~\\ % (fold)
\label{par:cart_position_counter}
This component maintains a counter which is incremented or decremented at every tick generated by the incremental quadrature decoder depending on the state of the direction signal.
If the endstop 1 signal is set high the counter is set to zero.
Upon booting the system the cart should be moved to the rightmost end-stop in order to calibrate the system.
Moving the cart will now increment the position with leftward motion and decrement with rightward motion.

\begin{figure}[h]
	\centering
	\includegraphics[width=.75\linewidth]{graphics/count_state_machine}
	\caption{State machine of the cart position counter created for the MicroZed.}
	\label{fig:countstatemachine}
\end{figure}

The SM of the system can be seen in figure \ref{fig:countstatemachine}.
It should be noted that the end signal is treated as a reset signal and as such is not part of the actual SM.
Since it is essentially a reset signal handling of it is placed in the \texttt{sync process} to avoid an asynchronous reset of the values.
The code in question can be seen in listing \ref{code:cart_sync_proc}.

\begin{listing}[h]
\begin{minted}{vhdl}
SYNC_PROC:  process(clk)
	begin
	    if rising_edge(clk) then
	        if emend = '0' then
	            counter_i <= (others => '0');
	            state <= st1_idle;
	            cal_i <= '1';
	        else
	            state <= next_state;
	            counter_i <= next_counter_i;
	            last_T_i <= T_i;
	        end if;
	    end if;
	end process;
\end{minted}
\caption{VHDL code}
\label{code:cart_sync_proc}
\end{listing}

The SM has only three simple states.
\texttt{st1\_idle} which is the state where the SM waits for a rising edge on the tick signal, \texttt{T}.
If the direction signal, \texttt{D} is low when a tick arrives the SM proceeds to \texttt{st2\_cw} if the opposite is true it proceeds to \texttt{st3\_ccw}.
In those states the position variable, \texttt{C} is either decremented or incremented.

\paragraph{Test Benches}~\\ % (fold)
\label{par:test_benches}
A part of developing these components has been to develop and use test benches to verify code as it is being written.
VHDL was originally thought as a language to describe and simulate hardware and logic and has later been used as the programming language used to create FPGA designs.
All of the original features of the language are still present and as such it is possible to create a component which fully exercises whichever component is under development, the unit-under-test or UUT.
\\~\\
The test bench written for the cart position counter is comprised of three processes, the \texttt{clk\_proc} which is responsible for generating the driving clock for the component, \texttt{quad\_proce\_ccw} or \texttt{quad\_proce\_cw} for simulating the quadrature signal in either the counter-clockwise or the clockwise direction and finally the \texttt{stim\_proc} which is responsible for exercising any of the input signals.
\\~\\
The UUT is instantiated as a component in the test bench and Vivado provides tools for investigating the flow of execution.
An excerpt illustrating the functionality can be seen in figure \ref{fig:testbench}.
As can be seen \texttt{B\_i} is leading \texttt{A\_i}, resulting in \texttt{D\_i} going high.
Since \texttt{emend\_i} is high the component starts counting on every rising edge of \texttt{T\_i}.
When \texttt{emend\_i} goes low the counter is reset and future ticks are ignored until \texttt{emend\_i} returns to high.

\begin{figure}[h]
	\centering
	\includegraphics[width=\linewidth]{graphics/test_bench_narrow}
	\caption{State machine of the cart position counter created for the MicroZed.}
	\label{fig:testbench}
\end{figure}

\paragraph{Packaging an AXI-Enabled IP Core}~\\ % (fold)
\label{par:ip_cores}
Once the component is confirmed functioning as intended, the component is packaged as an IP core capable of AXI communication.
Vivado provides an IP packager which auto-generates the files required for instantiating the components for AXI-communication.
The user can choose the number and width of the registers to be available in the instantiated AXI component.
In the generated files the user is expected to add their own code and alter existing code such that it correctly implements the desired functionality.
\\~\\
In relation to the components created in this project, the \texttt{.vhd} code files are imported to the project and the component instantiated.
Every user-defined port is brought out through the AXI component so that they can be constrained correctly in the \texttt{.xdc} constraint file.
Since every component is made as an IP core the system can be created using a block design.
For illustration purposes the block design of the full system has been included in figure \ref{fig:blockdesign}.
The rightmost blocks include three of the authors' designs and a Xilinx \texttt{axi\_gpio} block.
The GPIO block is used to handle hardware signals for creating an emergency state, enabling the motor driver and similar tasks.
As can be seen, a simple RGB LED controller has been written to handle the debug LEDs on the board.
By creating the component to control just a single LED, that code can be instantiated as many times as is required by the application and in any application.
In common for all of these blocks is that they require at least some of their input from the AXI bus.

\begin{figure}[h]
	\centering
	\includegraphics[width=\linewidth]{graphics/block_design}
	\caption{Vivado block design of the complete system.}
	\label{fig:blockdesign}
\end{figure}

\paragraph{Communication Through the AXI Bus}~\\ % (fold)
\label{par:communication_through_the_axi_bus}
In this project the AXI bus is used to communicate between PS and PL.
Doing this requires setup in both domains.
In PL registers are generated which the user can input data to.
An example of how this is set up can be seen in listing \ref{code:axiconnection}.
Individual bits in a register can be set to different variables and the remaining bits left unchanged.

\begin{listing}[h]
\begin{minted}{vhdl}
cart_counter_inst : cart_counter
	port map(
	    clk => clk,
	    A => A,
	    B => B,
	    Z => Z,
	    emend => emend,
	    cal => slv_reg0(1),
	    dir => slv_reg0(0),
	    pos => slv_reg1
	);
\end{minted}
\caption{Code showing the connection of AXI registers to the cart position counter signals.}
\label{code:axiconnection}
\end{listing}

In PS these registers can be accessed using the \texttt{Xil\_In32()} and \texttt{Xil\_Out32()}.
These functions require an address and in the case of the output function, a payload to write to the register.
Each device in the design is given a base address which can be found in the \texttt{xparameters.h} header file which is generated for each hardware design.
Accessing a parameter is then done by adding the appropriate offset.
The offset is determined by the width of the registers.
In this case registers are 32 bits wide and so every offset is \texttt{0x04} bytes.
In code this is handled as seen in listing \ref{code:axiconnectionps}

\begin{listing}[h]
\begin{minted}{c}
#define CART_BASEADDR XPAR_ZYBO_CART_COUNTER_V1_0_0_BASEADDR

#define CAL_ADDR		0x00
#define DIR_ADDR		0x00
#define POS_ADDR		0x04
	
#define CALIBRATED		0x01
		@$\vdots$@
	
void get_position(uint32_t *position)
{
	if(is_calibrated() == CALIBRATED)
	{
		*position = Xil_In32(CART_BASEADDR+POS_ADDR);
	}
	else
	{
		position = NULL;
	}
}

		@$\vdots$@
void cart_task(void)
{
	uint32_t* pos = NULL;
	if(get_position(pos) != NULL)
	{
		//Do Something
	}
		@$\vdots$@
}
\end{minted}
\caption[Excerpt from the code written to handle the communication with the cart position counter.]{Excerpt from the code written to handle the communication with the cart position counter. \texttt{is\_calibrated()} returns the status of calibration.}
\label{code:axiconnectionps}
\end{listing}

Here a wrapper function for \texttt{Xil\_In32()} is shown.
A number of these are written to simplify the code and reduce the risk of errors.
In this case the position is only valid if the calibration bit is set high.
When it is not, a null pointer is returned.
Rather than checking both the calibration status and the position, both can be done using a single function call.

\subsubsection{Interfacing the nRF24L01} % (fold)
\label{ssubs:nrf24l01}
~\\
The \texttt{nRF24L01} is interfaced through a standard SPI connection and a \texttt{CE} pin that is used to activate the chip. 
It also has an interrupt pin, but it was chosen not to use it and instead poll the device. 
Configuration of the device is done through SPI.

\paragraph{Setup} % (fold)
\label{par:nrfsetup}
~\\
Blablablalbalb.
Look at the nice flowchart and explain it.....
\missingfigure{FLOWCHART}
\mikkel{explain flowchart}
\thomas{create flowchart}
\paragraph{Writing to a Register} % (fold)
\label{par:writing_to_a_register}
~\\
Figure \ref{fig:rw_register} illustrates the bits that are sent to the \texttt{nRF24L01} in order to write a value to a register. 
The three command bits specify if the action to be done is read or write.
The five address bits specify address of the register that is to be written to. 
The next one to five bytes is the value that are to be written to the register.

\begin{figure}[!h]
	\centering
	\includegraphics[width=.3\linewidth]{graphics/rw_register.eps}
	\caption[Writing bits to a register on nRF24L01.]{Bits written to the \texttt{nRF24L01} in order to write a value to a register. \texttt{Command} specifies if it is a read or write action, \texttt{Address} specifies the register address and \texttt{Value} specifies the value written to or read from the register.}
	\label{fig:rw_register}
\end{figure}
\thomas{Figure should be updated with 1 byte more....}

The C code in listing \ref{code:rf_write_register_code} is used to write a value to a register. 
Line 5 makes sure that a valid address and command is sent, regardless of the inputs.
Line 6 collects all bits that needs to be sent in one variable. 
The 2 bytes are sent using SPI in line 7, where it can also be seen that the answer from the \texttt{nRF24L01} is ignored as the \texttt{NULL} pointer is given as the input buffer.  

\begin{listing}[!h]
\begin{minted}{c}
#define W_REGISTER      0b00100000
#define REGISTER_MASK   0b00011111

void RF_write_register(XSpiPs *SPI_inst, u8 reg, u8 value){
	u8 cmd_addr =  (W_REGISTER | ( REGISTER_MASK & reg));
	u8 output_buffer[] = {cmd_addr, value};
	XSpiPs_PolledTransfer(SPI_inst, output_buffer, NULL, 2);
}
\end{minted}
\caption{Implementation of a C function that writes a register value to a specific register on the \texttt{nRF24L01}. Macros are shown for clarity.}
\label{code:rf_write_register_code}
\end{listing}

The corresponding SPI signals are measured and plotted in figure \ref{fig:nrf24_spi}.
It can be seen that the \texttt{MOSI} signal corresponds to \texttt{0b00100000, 0b00110101}, which means that the value \texttt{0b00110101} is written to the \texttt{RF\_CONFIG} register which has address \texttt{0x00}.
It can also be noted that data is available on the \texttt{MISO} signal. 
The \texttt{nRF24L01} always responds with the value of the \texttt{STATUS} when detecting a falling edge on \texttt{SS}.

\begin{figure}[h]
	\centering
    \input{graphics/nrf24_spi.tex}
	\caption[SPI communication between nRF24 and the MicroZed]{SPI communication between \texttt{nRF24} and the MicroZed. Shown is a write command of \texttt{RF\_CONFIG} register, \texttt{0x00}. The value written to the \texttt{RF\_CONFIG} register is \texttt{0b00110101}. 2 bytes are exchanged in total. The SPI transmission is setup and measured at 625kHz, for readability.}
	\label{fig:nrf24_spi}
\end{figure}

\paragraph{Reading a Payload} % (fold)
\label{par:reading_a_payload}
~\\
Reading a payload from the \texttt{nRF24L01} is done as shown in figure \ref{fig:rxtx_payload}.
In general the first byte corresponds to the command given. 
In this case it would be \texttt{0b01100001} in order to read a payload.
The payload is the next one to 32 bytes sent by the \texttt{nRF24L01}.
\begin{figure}[h]
	\centering
	\includegraphics[width=.6\linewidth]{graphics/rxtx_payload.eps}
	\caption[Reading a payload on the nRF24L01.]{Bits written to and received from the \texttt{nRF24L01} when reading a payload. \texttt{Command} specifies the command given and \texttt{Payload} is the bits written from the \texttt{nRF24L01}.}
	\label{fig:rxtx_payload}
\end{figure}

Listing \ref{code:rf_read_payload} shows how a payload of 32 bytes are read in C code. 
Line 5 defines the input and output buffers and line 6 assigns the read payload command to the first byte of the output buffer.
33 bytes of data is sent in line 7, this is needed in order to create the clock signal for the \texttt{nRF24L01}, when it sends the 32 bytes payload.
The payload is also read and assigned to the input buffer in line 7.
Line 8-11 extracts the 32 bytes payload and ignores the first byte sent from the \texttt{nRF24L01}, which is the value of the \texttt{STATUS} register.

\begin{listing}[!h]
\begin{minted}{c}
#define R_RX_PAYLOAD       0b01100001
#define PAYLOAD_SIZE       32

void RF_read(XSpiPs *SPI_inst, u8 *buffer){
	u8 input_buffer[PAYLOAD_SIZE+1], output_buffer[PAYLOAD_SIZE+1];
	output_buffer[0] = R_RX_PAYLOAD;
	XSpiPs_PolledTransfer(SPI_inst, output_buffer, input_buffer, @$\Rightarrow$@
		PAYLOAD_SIZE+1);
	int i;
	for(i = 1; i < PAYLOAD_SIZE+1; i++){
		buffer[i-1] = input_buffer[i];
	}
}
\end{minted}
\caption{Implementation of a C function that reads 32 bytes payload from the \texttt{nRF24L01}. Macros are shown for clarity.}
\label{code:rf_read_payload}
\end{listing}

\subsubsection{PWM Generation} % (fold)
\label{ssub:pwm_generation}
In order to generate the two needed PWM signals from the Microzed an IP core must be made in VHDL.
As described the IP core needs to be able to switch the PWM signal between channel \texttt{A} and \texttt{B} and have a programmable duty cycle.
It also needs to have a top signal that indicates the center of the PWM pulse.
The designed PWM generator IP core has three inputs and three outputs as illustrated in figure \ref{fig:pwm_gen_component}.

\mikkel{Write about top signal in analysis.}
\begin{figure}[h]
	\centering
	\includegraphics[width=.4\linewidth]{graphics/pwm_generator}
	\caption{Input and output signals of the PWM generator component.}
	\label{fig:pwm_gen_component}
\end{figure}
A counter is incremented to a high limit and decremented to zero using a state machine.
The high limit for the counter when using the Microzed and a PWM frequency of 22KHz is calculated by:
\begin{equation}
	H_{limit} = \frac{F_{Microzed}}{F_{PWM}\cdot 2} = \frac{100\cdot 10^6}{22\cdot 10^6 \cdot 2} = 2272.7 \simeq 2273
\end{equation}
Where $H_{limit}$ is the high counting limit, $F_{Microzed}$ and $F_{PWM}$ are the frequencies of the Microzed and the PWM, respectively. 
The PWM output will be set \texttt{high}, when the counter value is greater than a compare value.
Using this mechanism the duty cycle of the PWM can be controlled through the compare value.
The compare value for a 50\% dutycycle should be calculated using:
\begin{equation}
	Compare = (1 - D) \cdot H_{limit} = (1 - 0.5) \cdot 2273 = 1136
\end{equation}
Where $Compare$ is the compare value and $D$ is the wanted dutycycle ratio.

The described mechanism is illustrated in figure \ref{sfig:pwm_gen_int}, where the top signal is simply set \texttt{high}, when the counter reaches its high limit.

\begin{figure}
    \centering
    \begin{subfigure}[b]{0.45\textwidth}
        \input{graphics/vhdl_pwm_gen_int.tex}
        \caption{Internal VHDL signals illustrated by a Matlab plot.}
        \label{sfig:pwm_gen_int}
    \end{subfigure}
    \begin{subfigure}[b]{0.45\textwidth}
        \input{graphics/vhdl_pwm_gen.tex}
        \caption{External PWM signal measured using an oscilloscope. }
        \label{sfig:pwm_gen_ext}
    \end{subfigure}
    \caption[Signals associated with the PWM generator IP core]{Internal and external signals associated with the PWM generator IP core. PWM and TOP are logic signals and 2000 represents their \texttt{high} value.}
    \label{fig:vhdl_pwm_gen}
\end{figure}

Generating the PWM signal from the counter and compare values is done in lines 5 to 11 of listing \ref{code:vhdl_pwm_gen}.
Setting the PWM on to the correct channel is done in lines 12 to 16.
As \texttt{pwm\_a\_l} and \texttt{pwm\_b\_l} are written to while in a process, they will only be updated with the last written value, at the end of the process.

\mikkel{make sure figure is at right place}
\begin{listing}[!h]
\begin{minted}{vhdl}
OUTPUT_DECODE: process (state,counter,dir)
begin
	@$\vdots$@
if (counter > unsigned(comp_value)) then
		pwm_a_l <= '1';
		pwm_b_l <= '1';
	else
		pwm_a_l <= '0';
		pwm_b_l <= '0';
	end if;	
	if( dir = '1') then 
		pwm_b_l <= '0';
	else 
		pwm_a_l <= '0';	
	end if;
end process;		
\end{minted}
\caption[VHDL code generating PWM signals.]{VHDL code generating PWM and setting it to the correct channel.}
\label{code:vhdl_pwm_gen}
\end{listing}

\subsubsection{KHAos and Real-Time Software} % (fold)
\label{ssub:khaos}
KHAos is a run-to-complete scheduler written by Karsten Holm Andersen, lecturer at SDU.
It is written to provide a simple operating system, OS, for use on bare-metal systems.
The OS includes of a timer module and a CPU config module which are written specifically for the platform that the OS should be running on.
The software also includes the scheduler itself, \texttt{schedule.c} and a pair of configuration files \texttt{rtcs.h} and \texttt{rtcscnf.h}.
\\~\\
It should be noted that while the authors did set up a functioning KHAos system it saw no actual use in the verification of features due to time constraints.
The steps to properly configure KHAos are presented here to provide an overview of the process.
% subsubsection khaos (end)

\subsection{Verification} % (fold)
\label{sub:verification}
\thomas{write verifications}