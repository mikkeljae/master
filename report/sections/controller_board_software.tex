%!TEX root = ../main.tex
\section{Controller Software Development} % (fold)
\label{sub:controller_board_software}

\subsection{Analysis} % (fold)
\label{sub:analysis}
This section will seek to analyse the requirements for the software that runs on the MicroZed mounted on the controller board.
The software will need to serve as a base system, where control algorithms can be run for verification purposes.
It is not intended as the final system as that system should be Linux based and imposes a completely different set of requirements on the system.

\subsubsection{Cart Position} 
\label{ssub:cart_position}
In order to control the position of the cart it is important to know its absolute position.
The \texttt{HEDS5540} \cite{heds5540} encoder mounted on the motor has an \texttt{A}, \texttt{B} and \texttt{Z} incremental quadrature and can be used to measure the relative position of the cart. 
The absolute position of the cart should be referred to the rail and therefore the \texttt{Z} signal cannot be used to determine the absolute position.
The endstops have fixed positions on the rail and the signals from them can therefore be used to infer the absolute position.
Specifically, resetting the position when reaching endstop 1 should be done to calibrate the system.
Hereafter the absolute position can be measured by reading signals \texttt{A} and \texttt{B}.

Implementing this functionality on an FPGA using VHDL has the advantage that all signals can be read simultaneously.
This means that a correct VHDL design will ensure that no edges on pins can go unnoticed.
Furthermore it has the advantage that the processor does not need to do any computation and no jitter is introduced, since no interrupts are used. 
Therefore it was decided to implement the functionality of measuring absolute cart position in a VHDL module.


\subsubsection{Controlling the Motor Driver} % (fold)
\label{ssub:controlling_the_motor_driver}
The motor driver has three inputs that need to be produced by the controller board software.
More specifically, two PWM inputs and a disable pin that disables the outputs of the motor driver.
The PWM signals will be applied to the motor and therefore it was chosen to use a frequency of 22kHz in order to be outside of the audible range.
It was decided to only apply a PWM signal to one channel in order to reduce the stress and current through the MOSFET and the motor.
This means that in order to change direction of the motor, the PWM signal needs to be switched between the two PWM channels.
The duty cycle of the PWM needs to be adjustable in order to control the speed of the motor.
\\
As described earlier, the current through the motor needs to be sampled using an ADC. 
By sampling at the t
\mikkel{SQUIRREL!}
It is beneficial to implement the PWM generation on the FPGA part of the MicroZed as it has no dedicated PWM generating hardware and implementing it in software would require computational time on the processor.

\subsubsection{General Peripheral Hardware Control} % (fold)
\label{ssub:general_peripheral_hardware}
As described in section \ref{ssub:relay_circuitry}, two relays should be controlled by the controller board software. 
An inrush relay that allows for safe charging of the capacitor bank and the main relay. 
Both are controlled by controlling the logic level of an output pin.
Furthermore the software needs to control the three RGB LEDs on the controller board. 
In order to utilize the full functionality of the RGB LEDs each channel of the LED should be controlled by a PWM signal.
Using this method an LED can be illuminated in all colours.
The frequency of the PWM is not of great concern as long as it is faster than a human eye. 
A higher frequency means a higher loss in the MOSFETs and therefore a frequency of 1kHz was chosen, this is fast enough to avoid visible flickering.

\subsubsection{Interboard Communication} % (fold)
\label{ssub:interboard_communication}
The joint boards need to transmit joint angles to the controller board wirelessly using the \texttt{nRFM}.
In section  \ref{ssub:wireless_transmission_of_data} it is determined that two bytes are needed to represent the joint angle data.
The rate of transmission of joint angles should be as high as possible while still maintaining reliable transmission.
Throughout this section this aspect is explored further.

With knowledge of the message size, it is possible to determine the theoretical maximum transmission rate.
The \texttt{nRFM} is capable of transmitting up to 2Mbps.
It uses Enhanced Shockburst, a protocol developed by Nordic Semiconductor specifically for their RF modules.
This protocol adds an overhead for each packet of 6 bytes, including a CRC check and an address, amongst a few other features.
Each packet is therefore $\approx$ 8 bytes with only 25\% of the packet being the intended payload.
This effectively limits the data rate to 0.5Mbps.
It is therefore possible to transmit a position at a rate of 31250Hz.
Since the two joints are communicating with the same module on the controller board, this frequency is halved resulting in 15625Hz.
Transmission at this frequency does entail a few problems, discussed in the following paragraphs.
\paragraph{nRF24L01 Mode Cycling}~\\ % (fold)
\label{par:nrf24l01_mode_cycling}
When transmitting at a rate of 15625Hz a message is to be sent every 64$\mu$s
According to the datasheet of the \texttt{nRFM} it can be kept in transmit mode for no longer than 4ms, meaning that at the most 62 packets can be sent before cycling to standby-mode and back to TX-mode.
Before entering TX-mode a 130$\mu$s settling period is inferred.
This means that at least two packets are lost during this time.
The problem can be overcome by lowering the transmission frequency such that the time between packets is above 130$\mu$s.
%6.25kHz transmission frequency would result in 160$\mu$s delay, enough time to cycle between the modes between each packet.


\paragraph{Air Collisions}~\\
\label{par:air_collisions}
There is a risk that two packets will collide if the joints transmit at the same time.
Due to uneven drift between the two microcontrollers on the joints it is unlikely that collisions will occur indefinitely, however even a few lost packets in a row can cause severe problems in the control of the pendulum.
The lowered transmission frequency alleviates this issue somewhat, but there is still a risk that multiple packets may be lost.
Air collisions could be handled by using the acknowledge feature in the Enhanced Shockburst protocol, this enables the module to resend a message if an ACK message has not been received within 250$\mu$s.
After 250$\mu$s however, the previous position is outdated and the new position should be sent rather than the lost position.
Additionally, the ACK message adds 15 bytes to the transmission of each packet, greatly lowering the possible throughput.
The \texttt{nRFM} is capable of operating on different frequency-bands.
By adding a second receiver on the controller board the two joints can communicate on different frequencies, eliminating the risk of air collisions altogether.
This realisation was made after the controller board was produced and so the additional \texttt{nRFM} has to be retrofitted on the board. 
% paragraph air_collisions (end)
\\~\\
In order to simplify communication between the joint boards and the controller board communcation will be one way only.
This allows the \texttt{nRFM}s on the controller board to stay in RX-mode, listening for new positions from the joints continuously.
The joint boards will, upon powering up, immediately start transmitting the packet mentioned in figure \ref{fig:rfpacket}.

\subsubsection{Utilizing the Zynq Platform} % (fold)
\label{ssub:utializing_the_zynq_platform}
The MicroZed has a Xilinx Zynq 7020 chip embedded on the board. 
This chip has both a Processing System, PS, and Programmable Logic, PL, which enables the use of both concurrent and sequential computing on the same board. 
The PS is a dual core ARM Cortex-A9 processsor and PL is an Artix-7 FPGA \cite{zynq_data_sheet}.
The two parts are connected through the AXI bus.

\paragraph{Concurrent Computing}~\\ % (fold)
\label{par:concurrent_computing}
Programming an FPGA will be done using VHDL, which is a description of hardware rather than a programming language. 
Everything in an FPGA is essentially electronics which makes it possible to do computation in true parallel. 
An FPGA is inherently real-time as it can be analysed exactly how many clock cycles propagation delay there is through a system.

\paragraph{Sequential Computing}~\\ % (fold)
\label{par:sequential_computing}
Programming on a processing systems such as the ARM processor is sequential computing. 
Everything that should be calculated is done by the CPU, which means that code is run sequentially.
True parallel computing cannot be done on such a chip, but using an OS and tasks it is possible to achieve an approximation to parallel computing.
It is possible to make real-time software on a processing system if care is taken by the programmer to meet the required deadlines. 

\paragraph{The AXI Bus and IP Cores}~\\ % (fold)
\label{par:the_axi_bus}
The AXI, Advance eXtensible Interface, standard is part of Arm AMBA, an industry standard for communication between components on SoCs.
AXI4 has been co-developed with Xilinx in an effort to tailor it for use in FPGAs.
Perhaps not surprisingly, Xilinx uses this protocol extensively in their IP, Intellectual Property.
It increases portability by allowing a single interface between different components.
The use of IP allows companies to share functionality without disclosing the underlying code, but also simplifies the connection of various components since every component can be verified independently of the others and can be easily connected using the Block Design feature of Vivado.
AXI is a memory-mapped interface, meaning that communication through the bus is essentially a controlled sharing of specific memory.
Communication between PS and PL requires the use of the AXI bus.
\\~\\
There are three different implementations of the AXI bus:
\begin{itemize}
	\item \textbf{AXI4-Full:} This implementation enables burst transmissions, allowing multiple data transmissions per interaction.
	\item \textbf{AXI4-Lite:} This implementation is lower bandwidth than the above implementation but is especially useful for setting control registers and transmitting low volumes of data.
	\item \textbf{AXI4-Stream:} This implementation foregoes the use of addresses and allows a continuous stream of data.
\end{itemize}
Since the data exchanged between PL and PS in this project is mostly the setting of control registers and reading cart positions at a steady rate the simpler AXI4-Lite implementation is going to be used for the components created in this project.
\subsubsection{Real-Time Software} % (fold)
\label{ssub:real_time}
In general control systems are created as real-time systems.
This ensures that any time-stepping done in the mathematics of the system is well-defined and that the control is therefore well-defined.
Also the literature used as an inspiration for this project \cite{invertpendulum1} \cite{doubleinvertpendulum} \cite{tripleinvertpendulum} describe real-time systems based on real-time linux and DSpace.
Therefore the software developed here, will also be real-time.

\subsubsection{VHDL and Coding Practices} % (fold)
\label{ssub:vhdl_and_coding_practices}
Some of the software components are written in VHDL.
As the reader likely knows, programming in VHDL can be a complex venture.
The Zynq platform adds another layer of complexity in requiring communication through the AXI Bus.
In order to minimize the complexity of the VHDL programming task a number of practices will be employed by the authors:
\begin{itemize}
	\item \textbf{Utilization of Test Benches:} VHDL was developed primarily as a means to simulate hardware.
	This ability means that any code can be verified in simulation before being synthesised.
	In simulation the value of any register and signal can be monitored, greatly easing the task of debugging the system.
	Additionally, each iteration is significantly faster since it foregoes the need for the complete bitstream on every iteration.
	\item \textbf{Atomic Components:} In the experience of the authors, the complexity of writing VHDL rises rapidly with the number of features of a given component.
	Writing components in their atomic form, that is, writing components with as few features as is possible, makes it significantly easier to debug and finalise each component.
	More complex components can then be made up of several smaller, known-to-function components.
	\item \textbf{Utilization of IP Cores:} Vivado, the development environment for the Zynq platform, relies heavily on the concept of Intellectual Property Cores.
	VHDL components can be compiled into an IP core which can then be easily distributed amongst multiple users.
	They also provide a means to more easily build a system by connecting several IP cores of arbitrary complexity.
\end{itemize}
In addition to the points made above, it is the expectation that future developers will develop Linux drivers which provide an intuitive interface to the firmware developed in this project.

\subsubsection{Requirement Specification} % (fold)
\label{ssub:controller_requirements}
The requirements specified below are tested and verified in section \ref{ssub:verification_controller_board_software}.
\paragraph{Functional:}
\begin{enumerate}[resume]
	\item Correct cart position should be known at all times.
	\label{enum:correct_cart_position}
	\begin{itemize}
		\item Encoder signals should be used to measure relative position.
		\item Endstop signal should be used to calibrate and infer the absolute position.
	\end{itemize}
	\item General peripheral hardware should be controlled.
	\label{enum:general_peripheral_hardware}
	\begin{itemize}
		\item Main relay and inrush relay should be controlled through output pins.
		\item 3 channel 1kHz PWM with adjustable duty cycle should control each RGB LED.
	\end{itemize}
	\item Software should produce correct signals to motor driver that allows for control of speed and direction of the motor.
	\label{enum:software_correct_motor_driver_signals}
	\begin{itemize}
		\item 22kHz PWM signals on two channels.
		\item Adjustable duty cycle.
		\item Control \texttt{DIS} signal.
 	\end{itemize}
	\item Receive joint angle data from the two joint boards using the \texttt{nRFM}.
	\label{enum:receive_joint_angle}
	\begin{itemize}
		\item MicroZed as SPI master.
		\item Setup of \texttt{nRFM} settings.
		\item Receive joint angle data form joint boards.
	\end{itemize}
	\item Real-time behaviour of software.
	\label{enum:real_time_behavior}
\end{enumerate}

\paragraph{Design:}
\begin{enumerate}[resume]
	\item VHDL modules should be designed and implemented using the following practices.
	\label{enum:vhdl_implementation_practices}
	\begin{itemize}
		\item Utilization of Test Benches.
		\item Atomic Components.
		\item Utilization of IP Cores.
	\end{itemize}
\end{enumerate}
\paragraph{Safety:}
\begin{enumerate}[resume]
	\item Software should handle emergency situations.
	\label{enum:software_should_handle_emergency}
	\begin{itemize}
		\item Should detect emergency condition.
		\item Should be able to produce an emergency signal.
	\end{itemize}
\end{enumerate}

\subsection{Design and Implementation} % (fold)
\label{sub:implementation}
This section presents the design and implementation of the software written for the controller board.
The process used for writing VHDL components in this project is presented and the associated C code shown.
Finally the setup of wireless communication for the MicroZed.
\thomas{Done - introduction to design and implementation of control software section}
\subsubsection{Implementation of Cart Position Counter} % (fold)
\label{ssub:vhdl_components}
A number of VHDL components were designed and implemented for use on the MicroZed.
An indepth description of each is not necessary and the authors have decided to instead focus on the implementation of just the cart position counter as it provides a good description of the workflow used for each component.
\\~\\
The cart position counter is, as the name implies, responsible for maintaining knowledge of the current position of the cart.
This is done by decoding the incremental quadrature of the motor and reading the state of the endstops.
Absolute knowledge of the cart position can be maintained by initially moving the cart to one of the endstops, setting the position to zero and then keeping the cart between the two endstops.
The decoding task is done by a seperate component which is then instantiated in the counting component.

\paragraph{Incremental Quadrature Decoding}~\\ % (fold)
\label{par:incremental_quadrature}
The motor provides three signals for incremental quadrature, \texttt{A}, \texttt{B} and \texttt{Z}. 
Figure \ref{fig:quadrature} is a depiction of this quadrature scheme.
The two signals \texttt{A} and \texttt{B} are 90$^\circ$ out of phase and their frequency is determined by the angular velocity of the joint.
As can be seen from the figure the signals create four unique stages, counting these allows knowledge of both the direction, position and, potentially, the velocity of the joint.
The \texttt{Z} signal is a unique pulse which happens on every revolution of the motor.

\begin{figure}[h]
	\centering
	\includegraphics[width=.5\linewidth]{graphics/quadrature}
	\caption[Incremental quadrature as implemented on the \texttt{HEDS5540}]{Incremental quadrature scheme as implemented on the \texttt{HEDS5540}.}
	\label{fig:quadrature}
\end{figure}

\paragraph{State Machine Structure}~\\ % (fold)
\label{par:state_machine_structure}
Each state machine written for this project is done using a Moore SM in a three-part structure:
\begin{itemize}
	\item \textbf{Sync Process:} This is the only process which is synchronized with the clock signal.
	It is used to ensure that state and signals are changed only on the rising edge of the clock.
	\item \textbf{Output Decode:} In each state the output signals are to be in a specific configuration.
	Given any state, this process ensures that the signals are in that configuration.
	\item \textbf{Next State Decode:} In this process the next state is determined based on the current state and the current inputs.
\end{itemize}
Using this structure ensures that each process has one responsibility and will generally result in cleaner, more simple code.
\\~\\
The component described in this section is comprised of two subcomponents.
The first is a state machine responsible for reading the current direction of travel and generating a tick on every edge of signals \texttt{A} and \texttt{B}.
A depiction of the SM responsible for decoding the incremental quadrature can be seen in figure \ref{fig:quadstatemachine}.
On this figure \texttt{A}, \texttt{B} and \texttt{Z} are the quadrature signals, \texttt{p} and \texttt{pl} are the \texttt{phase} and \texttt{last\_phase} variables, \texttt{T\_i}, \texttt{D\_i} and \texttt{I\_i} are the \texttt{tick}, \texttt{direction} and \texttt{index} variables.
Note that VHDL notation has been omitted for clarity.
As can be seen, the SM is comprised of six states, explained in more detail in the following paragraphs.
\begin{figure}[h]
	\centering
	\includegraphics[width=.85\linewidth]{graphics/quad_state_machine}
	\caption[State machine of incremental quadrature decoder.]{State machine of the incremental quadrature decoder created for the MicroZed.}
	\label{fig:quadstatemachine}
\end{figure}
\paragraph{st1\_idle:} % (fold)
Is the initial state and the state that is returned to between edges on the quadrature signal.
Since the quadrature signal is not synchronous with the driving clock of the system the \texttt{rising\_edge()} and \texttt{falling\_edge()} functions cannot be used to determine edges.
Listing \ref{code:edge_detection} shows how an edge is detected on a signal. 
The current value of the signal is continuously compared to the last value, which is saved on every clock cycle.
If the two values are not equal an edge must have occured within the last clock cycle.
In this component both rising and falling edges are used and so any difference between the two is registered.
This code is repeated for all three input signals, with the exception that the \texttt{Z} channel sets \texttt{next\_state} to \texttt{st6\_index} instead.

\begin{listing}[H]
\begin{minted}{vhdl}
case (state) is
	when st1_idle =>
		if A_i /= last_A_i then
	        next_state <= st2_edge;
	    end if;
	    @$\vdots$@
\end{minted}
\caption{VHDL edge detection of asynchronous signal.}
\label{code:edge_detection}
\end{listing}

\paragraph{st2\_edge:} % (fold)
Is responsible for determining which phase is currently active.
The different phases can be seen in figure \ref{fig:quadrature}.
The phase is found simply by comparing the signals as seen in listing \ref{code:phase_detection}.
Regardless of the detected phase \texttt{next\_state} is set to \texttt{st3\_dir}.
\begin{listing}[H]
\begin{minted}{vhdl}
when st2_edge =>
	if A = '1' then
	    if B = '1' then
	        phase <= p4;
	    else
	        phase <= p3;
	    end if;
	    next_state <= st3_dir;
	    @$\vdots$@
\end{minted}
\caption{VHDL for phase detection in incremental quadrature.}
\label{code:phase_detection}
\end{listing}
\paragraph{st3\_dir:} % (fold)
Determines the current direction of travel.
This can be seen by comparing the current phase to the last phase.
Listing \ref{code:determine_direction} shows the structure of the code responsible for this step.
\begin{listing}[H]
\begin{minted}{vhdl}
when st3_dir =>
	if last_phase /= p0 then
	    if phase = p1 then
	        if last_phase = p4 then
	            next_state <= st5_ccw;
	        end if;
	        if last_phase = p2 then
	            next_state <= st4_cw;
	        end if;
	        next_last_phase <= p1;
	    end if;
	    if phase = p2 then
	    @$\vdots$@
    else
        next_last_phase <= phase;
        next_state <= st1_idle;
    end if;
\end{minted}
\caption[VHDL for determining direction of movement.]{VHDL for determining direction of movement in incremental quadrature.}
\label{code:determine_direction}
\end{listing}
As can be seen in the code there is a reference to phase 0.
This is required since the initial phase is unknown.
During the first run the direction-determination is skipped and \texttt{last\_phase} is initialized to \texttt{phase}.
On every subsequent run, depending on the direction, \texttt{next\_state} is set to either \texttt{st4\_cw} or \texttt{st5\_ccw}.
\paragraph{st4\_cw and st5\_ccw:} % (fold)
The SM is in these states for one clock cycle to allow for the outputs to be adjusted and a tick to be generated.
\paragraph{st6\_index:} % (fold)
The SM is in this state for one clock cycle when the \texttt{Z} input goes high and generates a signal to indicate that the index has been reached.
While this feature is unused in the cart position counter as it currently exists, it was decided to include it to allow future developers to use it if the need arises.

\paragraph{Cart Position Counter}~\\ % (fold)
\label{par:cart_position_counter}
This component maintains a counter which is incremented or decremented at every tick generated by the incremental quadrature decoder depending on the state of the direction signal.
If the endstop 1 signal is set high the counter is set to zero.
Upon booting the system the cart should be moved to the rightmost end-stop in order to calibrate the system.
Moving the cart will now increment the position with leftward motion and decrement with rightward motion.

\begin{figure}[h]
	\centering
	\includegraphics[width=.75\linewidth]{graphics/count_state_machine}
	\caption[State machine of the cart position counter]{State machine of the cart position counter created for the MicroZed.}
	\label{fig:countstatemachine}
\end{figure}

The SM of the system can be seen in figure \ref{fig:countstatemachine}.
In this figure \texttt{C} is \texttt{counter\_i}, \texttt{D} is \texttt{direction} and \texttt{T} is \texttt{tick}.
It should be noted that the end signal is treated as a reset signal and as such is not part of the actual SM.
Since it is essentially a reset signal handling of it is placed in the \texttt{sync process} to avoid an asynchronous reset of the values.
The code in question can be seen in listing \ref{code:cart_sync_proc}.

\begin{listing}[H]
\begin{minted}{vhdl}
SYNC_PROC:  process(clk)
	begin
	    if rising_edge(clk) then
	        if emend = '0' then
	            counter_i <= (others => '0');
	            state <= st1_idle;
	            cal_i <= '1';
	        else
	            state <= next_state;
	            counter_i <= next_counter_i;
	            last_T_i <= T_i;
	        end if;
	    end if;
	end process;
\end{minted}
\caption{Synchronous reset based on endstop signals.}
\label{code:cart_sync_proc}
\end{listing}

The SM has only three simple states.
\texttt{st1\_idle} which is the state where the SM waits for a rising edge on the tick signal, \texttt{T}.
If the direction signal, \texttt{D} is low when a tick arrives the SM proceeds to \texttt{st2\_cw} if the opposite is true it proceeds to \texttt{st3\_ccw}.
In those states the position variable, \texttt{counter\_i} is either decremented or incremented.

\paragraph{Test Benches}~\\ % (fold)
\label{par:test_benches}
A part of developing these components has been to develop and use test benches to verify code as it is being written.
VHDL was originally thought as a language to describe and simulate hardware and logic and has later been used as the programming language used to create FPGA designs.
All of the original features of the language are still present and as such it is possible to create a component which fully exercises whichever component is under development, the unit-under-test or UUT.
\\~\\
The test bench written for the cart position counter is comprised of three processes, the \texttt{clk\_proc} which is responsible for generating the driving clock for the component, \texttt{quad\_proce\_ccw} or \texttt{quad\_proce\_cw} for simulating the quadrature signal in either the counter-clockwise or the clockwise direction and finally the \texttt{stim\_proc} which is responsible for exercising any of the input signals.
\\~\\
\thomas{insert code snippet from testbench}

The UUT is instantiated as a component in the test bench and Vivado provides tools for investigating the flow of execution.
An excerpt illustrating the functionality can be seen in figure \ref{fig:testbench}.
As can be seen \texttt{B\_i} is leading \texttt{A\_i}, resulting in \texttt{D\_i} going \texttt{high}.
Since \texttt{emend\_i} is \texttt{high} the component starts counting on every rising edge of \texttt{T\_i}.
When \texttt{emend\_i} goes \texttt{low} the counter is reset and future ticks are ignored until \texttt{emend\_i} returns to \texttt{high}.

\begin{figure}[h]
	\centering
	\includegraphics[width=\linewidth]{graphics/test_bench_narrow}
	\caption{Excerpt of testbench simulation results.}
	\label{fig:testbench}
\end{figure}

\paragraph{Packaging an AXI-Enabled IP Core}~\\ % (fold)
\label{par:ip_cores}
Once the component is confirmed functioning as intended, the component is packaged as an IP core capable of AXI communication.
Vivado provides an IP packager which auto-generates the files required for instantiating the components for AXI-communication.
The user can choose the number and width of the registers to be available in the instantiated AXI component.
In the generated files the user is expected to add their own code and alter existing code such that it correctly implements the desired functionality.
\\~\\
In relation to the components created in this project, the \texttt{.vhd} code files are imported to the project and the component instantiated.
Every user-defined port is brought out through the AXI component so that they can be constrained correctly in the \texttt{.xdc} constraint file.
Since every component is made as an IP core the system can be created using a block design.
For illustration purposes the block design of the full system has been included in figure \ref{fig:blockdesign}.
The rightmost blocks include three of the authors' designs and a Xilinx \texttt{axi\_gpio} block.
The GPIO block is used to handle hardware signals for creating a safety condition, enabling the motor driver and similar tasks.
\thomas{rewrite for proper safety condition}
As can be seen, a simple RGB LED controller has been written to handle the debug LEDs on the board.
By creating the component to control just a single LED, that code can be instantiated as many times as is required by the application and in any application.
In common for all of these blocks is that they require at least some of their input from the AXI bus.

\begin{figure}[h]
	\centering
	\includegraphics[width=\linewidth]{graphics/block_design}
	\caption{Vivado block design of the complete system.}
	\label{fig:blockdesign}
\end{figure}

\paragraph{Communication Through the AXI Bus}~\\ % (fold)
\label{par:communication_through_the_axi_bus}
In this project the AXI bus is used to communicate between PS and PL.
Doing this requires setup in both domains.
In PL registers are generated which the user can input data to.
An example of how this is set up can be seen in listing \ref{code:axiconnection}.
Individual bits in a register can be set to different variables and the remaining bits left unchanged.

\begin{listing}[H]
\begin{minted}{vhdl}
cart_counter_inst : cart_counter
	port map(
	    clk => clk,
	    A => A,
	    B => B,
	    Z => Z,
	    emend => emend,
	    cal => slv_reg0(1),
	    dir => slv_reg0(0),
	    pos => slv_reg1
	);
\end{minted}
\caption[Code showing the connection of AXI registers]{Code showing the connection of AXI registers to the cart position counter signals.}
\label{code:axiconnection}
\end{listing}

In PS these registers can be accessed using the \texttt{Xil\_In32()} and \texttt{Xil\_Out32()}.
These functions require an address and in the case of the output function, a payload to write to the register.
Each device in the design is given a base address which can be found in the \texttt{xparameters.h} header file which is generated for each hardware design.
Accessing a parameter is then done by adding the appropriate offset.
The offset is determined by the width of the registers.
In this case registers are 32 bits wide and so every offset is \texttt{0x04} bytes.
In code this is handled as seen in listing \ref{code:axiconnectionps}

\begin{listing}[H]
\begin{minted}{c}
#define CART_BASEADDR XPAR_ZYBO_CART_COUNTER_V1_0_0_BASEADDR

#define CAL_ADDR    0x00
#define DIR_ADDR    0x00
#define POS_ADDR    0x04
	
#define CALIBRATED  0x01
		@$\vdots$@
	
void get_position(uint32_t *position)
{
	if(is_calibrated() == CALIBRATED)
		*position = Xil_In32(CART_BASEADDR+POS_ADDR);
	else
		position = NULL;
}

		@$\vdots$@
void cart_task(void)
{
	uint32_t* pos = NULL;
	if(get_position(pos) != NULL)
	{
		//Do Something
	}
		@$\vdots$@
}
\end{minted}
\caption[Code handling communication with the cart position counter.]{Excerpt from the code written to handle the communication with the cart position counter. \texttt{is\_calibrated()} returns the status of calibration.}
\label{code:axiconnectionps}
\end{listing}

Here a wrapper function for \texttt{Xil\_In32()} is shown.
A number of these are written to simplify the code and reduce the risk of errors.
In this case the position is only valid if the calibration bit is set \texttt{high}.
When it is not, a null pointer is returned.
Rather than checking both the calibration status and the position, both can be done using a single function call.

\subsubsection{Interfacing the nRF24L01} % (fold)
\label{ssubs:nrf24l01}
~\\
The \texttt{nRFM} is interfaced through a standard SPI connection and a \texttt{CE} pin that is used to activate the chip. 
It also has an interrupt pin, but it was chosen not to use it and instead poll the device. 
Configuration of the device is done through SPI.

\paragraph{Setup} % (fold)
\label{par:nrfsetup}
~\\
The \texttt{nRFM} has multiple different modes of operations and care should be taken when setting it up.
The flowchart of figure \ref{fig:nrf_setup} gives an overview of what registers are set in order to gain the settings used in this project.
A description of each step and register is given below.
\begin{figure}[h]
	\centering
	\includegraphics[width=.8\linewidth]{graphics/nfr_setup}
	\caption{Flowchart showing the setup process of the \texttt{nRFM} module.}
	\label{fig:nrf_setup}
\end{figure}
\begin{itemize}
	\item \texttt{RF\_SETUP} register is set in order to gain 1Mbps air transmission and maximum output power in TX mode.
	\item \texttt{RF\_CH} register is used to set the channel used. It should be set differently for each \texttt{nRFM} pair.
	\item \texttt{SETUP\_AW} register is set to use the shortest available address width of three bytes.
	\item \texttt{EN\_AA} register is set to disable auto acknowledgement.
	\item \texttt{SETUP\_RETR} register is set to disable automatic retransmission.
\end{itemize}

The \texttt{PWR\_UP} bit is then set to \texttt{1} to power up the module. 
A wait of 4.5ms is then initiated to allow for proper start-up of the crystal.
\\~\\
If receive mode, \texttt{RX}, is needed the \texttt{PRIM\_RX} bit should be set to \texttt{1} and the receive address written to \texttt{RX\_ADDR\_P0}.
Furthermore \texttt{RX\_PW\_P0} is set to 2 in order to set the payload size to two bytes.
Finally \texttt{EN\_RX\_ADDR} is set to enable data on data pipe 0 and \texttt{CE} is set \texttt{high} to initiate the transition to \texttt{RX} mode.
\\~\\
If transmit mode, \texttt{TX}, is needed \texttt{PRIM\_RX} should be set to \texttt{0} and the transmit address should be written to \texttt{PRIM\_RX}.
Hereafter \texttt{CE} is set \texttt{high} to initiate the transition to \texttt{TX} mode.

\paragraph{Writing to a Register} % (fold)
\label{par:writing_to_a_register}
~\\
Figure \ref{fig:rw_register} illustrates the bits that are sent to the \texttt{nRFM} in order to write a value to a register. 
The three command bits specify if the action to be done is read or write.
The five address bits specify address of the register that is to be written to. 
The next one to five bytes is the value that are to be written to the register.

\begin{figure}[!h]
	\centering
	\includegraphics[width=.5\linewidth]{graphics/rw_register.eps}
	\caption[Writing bits to a register on nRF24L01.]{Bits written to the \texttt{nRFM} in order to write a value to a register. \texttt{Command} specifies if it is a read or write action, \texttt{Address} specifies the register address and \texttt{Value} specifies the value written to or read from the register.}
	\label{fig:rw_register}
\end{figure}
\thomas{fix figure to include arbitrary length value}

The C code in listing \ref{code:rf_write_register_code} is used to write a value to a register. 
Line 5 makes sure that a valid address and command is sent, regardless of the inputs.
Line 6 collects all bits that needs to be sent in one variable. 
The 2 bytes are sent using SPI in line 7, where it can also be seen that the answer from the \texttt{nRFM} is ignored as the \texttt{NULL} pointer is given as the input buffer.  

\begin{listing}[!h]
\begin{minted}{c}
#define W_REGISTER      0b00100000
#define REGISTER_MASK   0b00011111

void RF_write_register(XSpiPs *SPI_inst, u8 reg, u8 value){
	u8 cmd_addr =  (W_REGISTER | ( REGISTER_MASK & reg));
	u8 output_buffer[] = {cmd_addr, value};
	XSpiPs_PolledTransfer(SPI_inst, output_buffer, NULL, 2);
}
\end{minted}
\caption[C function that writes a value to a register on the nRFM]{Implementation of a C function that writes a register value to a specific register on the \texttt{nRFM}. Macros are shown for clarity.}
\label{code:rf_write_register_code}
\end{listing}

The corresponding SPI signals are measured and plotted in figure \ref{fig:nrf24_spi}.
It can be seen that the \texttt{MOSI} signal corresponds to \texttt{0b00100000, 0b00110101}, which means that the value \texttt{0b00110101} is written to the \texttt{RF\_CONFIG} register which has address \texttt{0x00}.
It can also be noted that data is available on the \texttt{MISO} signal. 
The \texttt{nRFM} always responds with the value of the \texttt{STATUS} when detecting a falling edge on \texttt{SS}.

\begin{figure}[h]
	\centering
    %\input{graphics/nrf24_spi.tex}
	\caption[SPI communication between nRF24 and the MicroZed]{SPI communication between \texttt{nRFM} and the MicroZed. Shown is a write command of \texttt{RF\_CONFIG} register, \texttt{0x00}. The value written to the \texttt{RF\_CONFIG} register is \texttt{0b00110101}. 2 bytes are exchanged in total. The SPI transmission is setup and measured at 625kHz, for readability.}
	\label{fig:nrf24_spi}
\end{figure}

\paragraph{Reading a Payload} % (fold)
\label{par:reading_a_payload}
~\\
Reading a payload from the \texttt{nRFM} is done as shown in figure \ref{fig:rxtx_payload}.
In general the first byte corresponds to the command given. 
In this case it would be \texttt{0b01100001} in order to read a payload.
The payload is the next one to 32 bytes sent by the \texttt{nRFM}.
\begin{figure}[h]
	\centering
	\includegraphics[width=.6\linewidth]{graphics/rxtx_payload.eps}
	\caption[Reading a payload on the nRF24L01.]{Bits written to and received from the \texttt{nRFM} when reading a payload. \texttt{Command} specifies the command given and \texttt{Payload} is the bits written from the \texttt{nRFM}.}
	\label{fig:rxtx_payload}
\end{figure}

Listing \ref{code:rf_read_payload} shows how a payload of 32 bytes is read in C code. 
Line 5 defines the input and output buffers and line 6 assigns the read payload command to the first byte of the output buffer.
33 bytes of data is sent in line 7-8, this is needed in order to create the clock signal for the \texttt{nRFM}, when it sends the 32 bytes payload.
The payload is also read and assigned to the input buffer in line 7-8.
Line 9-12 extracts the 32 bytes payload and ignores the first byte sent from the \texttt{nRFM}, which is the value of the \texttt{STATUS} register.

\begin{listing}[!h]
\begin{minted}{c}
#define R_RX_PAYLOAD       0b01100001
#define PAYLOAD_SIZE       32

void RF_read(XSpiPs *SPI_inst, u8 *buffer){
	u8 input_buffer[PAYLOAD_SIZE+1], output_buffer[PAYLOAD_SIZE+1];
	output_buffer[0] = R_RX_PAYLOAD;
	XSpiPs_PolledTransfer(SPI_inst, output_buffer, input_buffer, @$\Rightarrow$@
		PAYLOAD_SIZE+1);
	int i;
	for(i = 1; i < PAYLOAD_SIZE+1; i++){
		buffer[i-1] = input_buffer[i];
	}
}
\end{minted}
\caption[C function that reads 32 bytes payload from the nRFM]{Implementation of a C function that reads 32 bytes payload from the \texttt{nRFM}. Macros are shown for clarity.}
\label{code:rf_read_payload}
\end{listing}

\subsubsection{PWM Generation} % (fold)
\label{ssub:pwm_generation}
In order to generate the two needed PWM signals from the MicroZed an IP core must be made in VHDL.
As described the IP core needs to be able to switch the PWM signal between channel \texttt{A} and \texttt{B} and have a programmable duty cycle.
It also needs to have a top signal that indicates the center of the PWM pulse.
The designed PWM generator IP core has three inputs and three outputs as illustrated in figure \ref{fig:pwm_gen_component}.
\begin{figure}[h]
	\centering
	\includegraphics[width=.4\linewidth]{graphics/pwm_generator}
	\caption{Input and output signals of the PWM generator component.}
	\label{fig:pwm_gen_component}
\end{figure}
A counter is incremented to a high limit and decremented to zero using a state machine.
The high limit for the counter when using the MicroZed and a PWM frequency of 22KHz is calculated by:
\begin{equation}
	H_{limit} = \frac{F_{Microzed}}{F_{PWM}\cdot 2} = \frac{100\cdot 10^6}{22\cdot 10^3 \cdot 2} = 2272.7 \simeq 2273
\end{equation}
Where $H_{limit}$ is the high counting limit, $F_{MicroZed}$ and $F_{PWM}$ are the frequencies of the MicroZed and the PWM, respectively. 
The PWM output will be set \texttt{high}, when the counter value is greater than a compare value.
Using this mechanism the duty cycle of the PWM can be controlled through the compare value.
The compare value for a 50\% duty cycle should be calculated using:
\begin{equation}
	Compare = (1 - D) \cdot H_{limit} = (1 - 0.5) \cdot 2273 = 1136
\end{equation}
Where $Compare$ is the compare value and $D$ is the wanted duty cycle ratio.

The described mechanism is illustrated in figure \ref{sfig:pwm_gen_int}, where the top signal is simply set \texttt{high}, when the counter reaches its high limit.

\begin{figure}
    \centering
    \begin{subfigure}[b]{0.45\textwidth}
        %\input{graphics/vhdl_pwm_gen_int.tex}
        \caption{Internal VHDL signals illustrated by a Matlab plot.}
        \label{sfig:pwm_gen_int}
    \end{subfigure}
    \begin{subfigure}[b]{0.45\textwidth}
        %\input{graphics/vhdl_pwm_gen.tex}
        \caption{External PWM signal measured using an oscilloscope. }
        \label{sfig:pwm_gen_ext}
    \end{subfigure}
    \caption[Signals associated with the PWM generator IP core]{Internal and external signals associated with the PWM generator IP core. PWM and TOP are logic signals and 2000 represents their \texttt{high} value.}
    \label{fig:vhdl_pwm_gen}
\end{figure}

Generating the PWM signal from the counter and compare values is done in lines 4 to 10 of listing \ref{code:vhdl_pwm_gen}.
Setting the PWM on to the correct channel is done in lines 11 to 15.
As \texttt{pwm\_a\_l} and \texttt{pwm\_b\_l} are written to while in a process, they will only be updated with the last written value, at the end of the process.

\begin{listing}[H]
\begin{minted}{vhdl}
OUTPUT_DECODE: process (state,counter,dir)
begin
	@$\vdots$@
if (counter > unsigned(comp_value)) then
		pwm_a_l <= '1';
		pwm_b_l <= '1';
	else
		pwm_a_l <= '0';
		pwm_b_l <= '0';
	end if;	
	if( dir = '1') then 
		pwm_b_l <= '0';
	else 
		pwm_a_l <= '0';	
	end if;
end process;		
\end{minted}
\caption[VHDL code generating PWM signals.]{VHDL code generating PWM and setting it to the correct channel.}
\label{code:vhdl_pwm_gen}
\end{listing}

\subsubsection{KHAos and Real-Time Software} % (fold)
\label{ssub:khaos}
KHAos is a run-to-complete scheduler written by Karsten Holm Andersen, lecturer at SDU.
It is written to provide a simple operating system, OS, for use on bare-metal systems.
The OS includes a timer module and a CPU config module which are written specifically for the platform that the OS should be running on.
The software also includes the scheduler itself, \texttt{schedule.c} and a pair of configuration files \texttt{rtcs.h} and \texttt{rtcscnf.h}.
\\~\\
It should be noted that while the authors did set up a functioning KHAos system it saw no actual use in the verification of features due to time constraints.
The steps to properly configure KHAos are presented here to provide an overview of the process.
Defining the task names is done in \texttt{rtcscnf.h}.
An excerpt of the file can be seen in listing \ref{code:khaos_config}.
As can be seen, every task created in the system is associated with an ID and is given an init function.
The init function is used to set up hardware and other pre-requisites for the task and eventually to start the task. 
\begin{listing}[H]
\begin{minted}{c}
#define T_TICK 1

#define LAST_TASK 1

#define TASK0 alive_task
#define TASK1 cart_task
#define TASK2 NULL
#define TASK3 NULL

#define INIT_TASK0 init_alive_task
#define INIT_TASK1 init_cart_task
#define INIT_TASK2 NULL
#define INIT_TASK3 NULL

#define ALIVE_TASK 0
#define CART_TASK 1
\end{minted}
\caption[Configuration file of KHAos.]{Excerpt of the configuration file of KHAos. Each task is given an ID for both the task itself and its init function. The number of tasks in the system is given in \texttt{LAST\_TASK}.}
\label{code:khaos_config}
\end{listing}
The timer has been set up to provide a tick every 10$\mu$s.
This means that the period of the scheduler can be set in multiples of 10$\mu$s by setting the \texttt{T\_TICK} variable.
In this project it was chosen to use the shortest possible frequency while setting up the system.
Clearly, when more tasks are added to the system it is crucial to ensure that the deadline of each task is still upheld.
\\~\\
For the sake of verifying the system a simple \texttt{alive\_task} is set up which toggles one of the RGB LEDs on the controller board.
This task can be seen in listing \ref{code:alive_task}.
Every 0.5s this task flips the state of \texttt{RGB2} between the \texttt{off}-state and lighting the green LED.
The functions \texttt{set\_green()} and \texttt{set\_off()} are wrapper functions which hide the calls to \texttt{Xil\_Out32()} in an effort to simplify the code.
\begin{listing}[H]
\begin{minted}{c}
void alive_task(void)
{
	if(led)
		set_green(RGB2_BASEADDR);
	else
		set_off(RGB2_BASEADDR);

	led = !led;

	_wait(MILLI_SEC(500));
}
\end{minted}
\caption[Alive task in KHAos.]{Alive task in KHAos. This task repeatedly switches one of the RGB LEDs on the controller board to green and \texttt{off}.}
\label{code:alive_task}
\end{listing}
% subsubsection khaos (end)

\subsection{Verification} % (fold)
\label{ssub:verification_controller_board_software}
\thomas{introduction to section}
\subsubsection{Verification of: Requirement \ref{enum:correct_cart_position}} % (fold)
\label{ssub:verification_of_requirement_enum:correct_cart_position}
This requirement states that correct cart position should be known at all times.

\paragraph{Test}~\\
Cart should by moved back and forth and the cart position variable should increment and decrement accordingly.
The position should be set to zero, when moving the cart to the position of endstop 1.
\\
Drifting of the counter should be tested by placing the cart at a fixed position and noting the position variable.
Then the cart should be moved back and forth for some time and then placed at the initial fixed position. 
The position variable should have the same value as when initially held at the fixed position.

\paragraph{Conclusion}~\\
The test procedure described above was followed and it was found that the cart position variable is correctly increased, decreased and it was set to zero when reaching endstop 1.
\\
The drifting test was done by noting the counter position at the position of endstop 2. 
Hereafter the cart was moved back and fourth at different velocities for several minutes before returning it to the place of endstop 2. 
The position counter was the same, indicating that drifting is not present in the system.
\\~\\
The length of the rail from endstop 1 to endstop 2 was measured to be 72387 ticks.

\subsubsection{Verification of: Requirement \ref{enum:general_peripheral_hardware}} % (fold)
\label{ssub:verification_of_requirement_enum:general_peripheral_hardware}
This requirement states that general peripheral hardware should be controlled.

\paragraph{Conclusion}~\\
It was tested that the two relays could be turned \texttt{on} and \texttt{off} successfully from the software.
Furthermore it was tested that the three RGB LEDs could be illuminated in all colors using the PWM generation.


\subsubsection{Verification of: Requirement \ref{enum:software_correct_motor_driver_signals}} % (fold)
\label{ssub:verification_of_requirement_enum:software_correct_motor_driver_signals}
This requirement specifies that software should produce correct signals to the motor driver that allows for control of speed and direction of the motor.

\paragraph{Test}~\\
PWM outputs and I/O pin \texttt{DIS} of the MicroZed should be applied to the motor through the controller board circuitry.
Through programming it should be possible to set speed and direction of motor.

\paragraph{Conclusion}~\\
The MicroZed was programmed and inserted in the connector on the controller board.
Setting different duty cycles yielded different velocities of the motor - as expected.
By programming the \texttt{DIR} bit it was possible to change the motor direction.
The motor was successfully stopped by setting the \texttt{DIS} variable \texttt{high}.

\subsubsection{Verification of: Requirement \ref{enum:receive_joint_angle}} % (fold)
\label{ssub:verificatation_of_requirement_enum:receive_joint_angle}
This requirement states that the software should receive joint angle data from the two joint boards using the \texttt{nRFM}.

\paragraph{Conclusion}~\\
Testing this requirement requires software to run on the joint board.
The joint board has a similar requirement, which states that it should be able to transmit joint angle data to the controller board.
This requirement is tested and concluding remarks are given in section \ref{ssub:requirement_enum:joint_transmit}.

\subsubsection{Verification of: Requirement \ref{enum:real_time_behavior}} % (fold)
\label{ssub:verification_of_requirement_of_requirement_enum:real_time_behavior}
This requirement states that all software should be real-time.
\paragraph{Conclusion}~\\
It was the intention to collect all of the written software in a real-time system based on KHAos.
This goal was not reached due to time constraints of the project. 

\subsubsection{Verification of: Requirement \ref{enum:vhdl_implementation_practices}} % (fold)
\label{ssub:verification_of_requirement_enum:vhdl_implementation_practices}
This requirement states that VHDL modules should be designed and implemented using the practices:
\begin{itemize}
	\item Utilization of Test Benches.
	\item Atomic Components.
	\item Utilization of IP Cores.
\end{itemize}

\paragraph{Conclusion}~\\
This was successfully done as described in section \ref{ssub:vhdl_components}. 

\subsubsection{Verification of: Requirement \ref{enum:software_should_handle_emergency}} % (fold)
\label{ssub:verification_of_requirement_enum:software_should_handle_emergency}
This requirement specifies that software should handle emergency situations.
\thomas{do safety condition transformation}
\paragraph{Test}~\\
Detecting a safety condition should be tested by triggering an emergency condition e.g. moving the cart to one of the endstop and record this using the MicroZed.
\\
Producing a safety condition should be done by setting the \texttt{EM\_MCU} signal \texttt{low}. 

\paragraph{Conclusion}~\\
It was found that the \texttt{EM\_DIS} signal that indicates a safety condition was not wired to the MicroZed Bergstak connector.
This should be done in order to record safety conditions.
\\~\\
No tests were performed on producing a safety condition because of time constraints.